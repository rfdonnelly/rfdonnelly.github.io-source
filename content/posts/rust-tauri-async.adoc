---
title: "Rust Tauri Async"
date: 2022-08-17T00:43:11Z
draft: true
---

:toc:

== Goal

Integrate async code into a Tauri application.
More specifically we want bidirectional communication between the Tauri webview and async Rust code.
Either side can initiate a request.
A request may or may not have a corresponding response.

The Tauri main thread manages both the webview and the async process.
The main thread sits between the two.

[graphviz]
.A diagram of our desired Tauri application
----
digraph G {
    rankdir=RL

    subgraph cluster_tauri {
        label="Tauri\nApplication"

        mt [label="Main Thread\n(Rust)", shape=square]
        ap [label="Async\nProcess\n(Rust)", shape=square]
        wv [label="Webview\n(JavaScript)", shape=square]

        wv -> mt -> ap [constraint=false]
        ap -> mt -> wv
     }
}
----

So we can break this up into two smaller problems: bidirectional communication between,

* the webview (JavaScript) and the main thread (Rust)
* the main thread (Rust) and the async process (Rust)

=== Additional Details

The async process can generate solicited or unsolicited messages.
In other words, messages that JavaScript asked for and messages that JavaScript did not ask for.

== Create a Tauri App

First we need to create a Tauri application.

Follow the https://tauri.app/v1/guides/getting-started/prerequisites/[Tauri Getting Started] instructions for installing the necessary prerequisites.

Run the `create-tauri-app` utility

[source,sh]
----
npm create tauri-app
----

And make the following entries/selections

[listing, subs="quotes"]
----
? What is your app name? *tauri-async*
? What should the window title be? *Tauri App*
? What UI recipe would you like to add? *create-vite*
? Add "@tauri-apps/api" npm package? *Yes*
? Which vite template would you like to use? *vue*
----

Then run build and run the application

[source,sh]
----
cd tauri-async
npm install
npm run tauri dev
----

.The Tauri application with the Vite + Vue template
image::create-tauri-app-vite-vue.png["The default application window for the Tauri Vite + Vue template"]

== Async Process

Next, we need to know what our async process looks like.
We're going to keep it really generic here to make this generally applicable to many specific applications.

We'll model our async process as a simple async function with an infinite loop that pulls input strings from an input channel and pushes output strings into an output channel.

Our async process model in `src-tauri/src/main.rs`

[source,rust]
----
use tokio::sync::mpsc;

// ...

async fn async_process_model(
    mut input_rx: mpsc::Receiver<String>,
    output_tx: mpsc::Sender<String>,
) -> Result<(), Box<dyn std::error::Error>> {
    loop {
        let input = input_rx.recv().await.ok_or_else(|| "channel closed")?;
        let output = input;
        output_tx.send(output).await?;
    }
}
----

Even though Tauri uses and re-exports (via the https://docs.rs/tauri/1.0.5/tauri/async_runtime/index.html[`tauri::async_runtime`] module) some of the Tokio types, it doesn't re-export everything we need.
So we'll need to add Tokio.

[source,sh]
----
cd tauri-src
cargo add tokio --features full
----

== Bidirectional Communication between Rust and JavaScript

Tauri provides two communication mechanisms Events and Commands.
Events be send in either direction while Commands can only go from JavaScript to Rust.

I choose to use Commands for JavaScript to Rust and Events for Rust to JavaScript with the assumption that Commands are better than Events.footnote:[I don't have an evidence to back this up.]

Establishing two-way communication between Rust and JavaScript is pretty straight-forward.
The Tauri docs do a good job covering them.

=== Possible Simplification

You can get by with async Tauri Commands only if:

* JavsScript initiates the communication
* Requests/responses are one-to-one or one-to-none

Otherwise, you also need Tauri Events.
In this case, our requirements are more general and thus require the more general Events.

=== The JavaScript Side

Replace the content of `src/components/HelloWorld.vue` with

[source,vue]
----
<script setup>
import { ref } from 'vue'
import { listen } from '@tauri-apps/api/event'
import { invoke } from '@tauri-apps/api/tauri'

const output = ref("");
const outputs = ref([]);
const inputs = ref([]);

function sendOutput() {
    console.log("js: js2rs: " + output.value)
    outputs.value.push({ timestamp: Date.now(), message: output.value })
    invoke('js2rs', { message: output.value })
}

await listen('rs2js', (event) => {
    console.log("js: rs2js: " + event)
    let input = event.payload
    inputs.value.push({ timestamp: Date.now(), message: input })
})
</script>

<template>
  <div style="display: grid; grid-template-columns: auto auto;">
    <div style="grid-column: span 2; grid-row: 1;">
      <label for="input" style="display: block;">Message</label>
      <input id="input" v-model="output">
      <br>
      <button @click="sendOutput()">Send to Rust</button>
    </div>
    <div style="grid-column: 1; grid-row: 2;">
      <h3>js2rs events</h3>
      <ol>
        <li v-for="output in outputs">
          {{output}}
        </li>
      </ol>
    </div>
    <div style="grid-column: 2; grid-row: 2;">
      <h3>rs2js events</h3>
      <ol>
        <li v-for="input in inputs">
          {{input}}
        </li>
      </ol>
    </div>
  </div>
</template>
----

Since the `HelloWorld` component is now calling an async function in setup, the `<HelloWorld>` component must now be placed in a https://vuejs.org/guide/built-ins/suspense.html[`<Suspense>`] component.
Modify `src/App.vue` as follows

[source,diff]
----
-  <HelloWorld/>
+  <Suspense>
+    <HelloWorld/>
+  </Suspense>
----

== Bidirectional Communication between the Main Thread and an Async Process

Passing messages between Rust and JavaScript may be straightforward but doing so between the Tauri main thread and an async process was not.
Mostly because I couldn't find any examples.

I'm pretty happy with the final implementation.

The inputs and outputs of the async process implemented as `tokio::mpsc` (Multi-Producer Single-Consumer).
We only have a single producer but there isn't a more specific channel primitive for single-producer, single-consumer.

=== Who Owns the Async Runtime

Tauri uses Tokio internally and abstracts this complexity from the user.
For example, Tauri uses Tokio but doesn't require an async main and a `#[tokio::main]` annotation.
Tauri hides all of this from use.

Tauri owns and constructs the Tokio runtime by default but allows you to manage Tokio yourself.
We can do this by simply adding the `#[tokio::main]` annotation, adding `async` to main, and then telling Tauri to use our Tokio runtime.

[source,rust]
----
#[tokio::main]
async fn main() {
    tauri::async_runtime::set(tokio::runtime::Handle::current());

    // ...
}
----

TODO: Is this even necessary if we do all async in Tauri (i.e. inside `tauri::Builder::setup`)?

=== Creating the Channels

Channels need to be created for both directions: inputs in to the async process and outputs out of the async process.
They should be created with the least scope possible.
To determine this, we need to figure out where we will be using them.

TODO: Finish

=== Running the Async Process

The async process can be run insider of Tauri or outside of Tauri.
Either will work but running outside of Tauri will require owning the Tokio runtime.

==== Inside Tauri

[source,rust]
----
async fn main() {
    ...

    let (async_process_input_tx, async_process_input_rx) = mpsc::channel(1);
    let (async_process_output_tx, async_process_output_rx) = mpsc::channel(1);

    tauri::Builder::default()
        .setup(|app| {
            tokio::spawn(async move {
                async_process(async_process_input_rx, async_process_output_tx).await
            });

            Ok(())
        }
        .run(...)
        ...
}
----

==== Outside Tauri

[source,rust]
----
async fn main() {
    ...

    let (async_process_input_tx, async_process_input_rx) = mpsc::channel(1);
    let (async_process_output_tx, async_process_output_rx) = mpsc::channel(1);

    tokio::spawn(async move {
        async_process(async_process_input_rx, async_process_output_tx).await
    });

    tauri::Builder::default()
        .run(...)
        ...
}
----

=== Main Thread to Async Process

=== Async Process to Main Thread

== Integrating Async Code


